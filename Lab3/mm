template<typename Key, typename InnerKey, typename Element>
    struct MultimapCell {
        using Map = LinkedMap<InnerKey, Element>;

        Key first;
        Map *second = nullptr;

        MultimapCell *prev = nullptr;
        MultimapCell *next = nullptr;

        MultimapCell *before = nullptr;
        MultimapCell *after = nullptr;

        MultimapCell() = default;

        explicit MultimapCell(Key key, Map *value, MultimapCell *before = nullptr, MultimapCell *prev = nullptr);

        MultimapCell &operator=(LinkedMap<InnerKey, Element> &rhs);
    };

    template<typename Key, typename InnerKey, typename Element>
    class MultiMap {
        using Cell = MultimapCell<Key, InnerKey, Element>;
        using Map = LinkedMap<InnerKey, Element>;
        using Hash = unsigned long;

        Cell *table[LINKED_MAP_SIZE_] = {nullptr};
        int primes[10] = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31};

        Cell *firstAdded = nullptr;
        Cell *lastAdded = nullptr;

        Hash hash(Key key) {
            Hash sum = 0;
            for (int i = 0; i < key.size(); i++) {
                sum += primes[abs(key[i] - 'a') % 10] * primes[i % 10];
            }

            return sum % LINKED_MAP_SIZE_;
        }

        Cell *put(Key key, Map *value) {
            Hash h = hash(key);

            if (!table[h]) {
                table[h] = new Cell(key, value);
                if (lastAdded) {
                    lastAdded->after = table[h];
                    table[h]->before = lastAdded;
                }
                lastAdded = table[h];
                if (!firstAdded) {
                    firstAdded = table[h];
                }

                return table[h];
            } else {
                Cell *cell = table[h];
                while (cell->next && cell->first != key) {
                    cell = cell->next;
                }

                if (cell->first == key) {
                    if (lastAdded) {
                        if (cell->before && cell != lastAdded) {
                            cell->before->after = cell->after;
                        }
                        if (cell->after) {
                            cell->after->before = cell->before;
                        }

                        if (cell != lastAdded) {
                            lastAdded->after = cell;
                            cell->before = lastAdded;
                            cell->after = nullptr;
                        }
                    }

                    lastAdded = cell;
                    *cell = *value;

                    return cell;
                } else {
                    cell->next = new Cell(key, value, lastAdded, cell);
                    if (lastAdded) {
                        lastAdded->after = cell->next;
                    }

                    lastAdded = cell->next;

                    return cell->next;
                }
            }
        }

        Cell *get(Key key) {
            long h = hash(key);
            if (!table[h]) {
                return nullptr;
            }

            Cell *ptr = table[h];
            while (ptr->next && ptr->first != key) {
                ptr = ptr->next;
            }

            if (ptr->first == key) {
                return ptr;
            } else {
                return nullptr;
            }
        }

    public:
        void eject(Key key, InnerKey innerKey) {
            Hash h = hash(key);
            if (table[h] == nullptr) {
                return;
            }

            Cell *ptr = table[h];
            while (ptr->next != nullptr && ptr->first != key) {
                ptr = ptr->next;
            }

            if (ptr->first == key) {
                ptr->second->eject(innerKey);
            } else {
                return;
            }
        }

        void ejectAll(Key key) {
            Hash h = hash(key);
            if (table[h] == nullptr) {
                return;
            }

            Cell *ptr = table[h];
            while (ptr->next != nullptr && ptr->first != key) {
                ptr = ptr->next;
            }

            if (ptr->first == key) {
                if (ptr->prev != nullptr) {
                    ptr->prev->next = ptr->next;
                } else {
                    table[h] = ptr->next;
                }
                if (ptr->next != nullptr) {
                    ptr->next->prev = ptr->prev;
                }

                delete ptr;
            } else {
                return;
            }
        }

        MultiMap() = default;

        ~MultiMap() {
            for (; lastAdded; lastAdded = lastAdded->before) {
                delete lastAdded;
            }
        }

        Map &operator[](Key &key) {
            Cell *map = get(key);

            if (!map) {
                Cell *cell = put(key, new Map());
                return *cell->second;
            } else {
                return *map->second;
            }
        }

        const Map &operator[](Key &key) const {
            Cell &map = *this[key];

            return map;
        }

        LinkedMapIterator<Cell> begin() { return LinkedMapIterator(firstAdded); }

        LinkedMapIterator<Cell> end() { return LinkedMapIterator<Cell>(nullptr); }
    };